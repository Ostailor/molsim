from __future__ import annotations

import shutil
import subprocess
import tempfile
from dataclasses import dataclass
from pathlib import Path


@dataclass
class XTBResult:
    success: bool
    energy: float | None
    homo: float | None
    lumo: float | None
    dipole: float | None
    message: str | None = None


def xtb_available() -> bool:
    return shutil.which("xtb") is not None


def _mol_to_xyz(mol, conf_id: int = 0) -> str:
    atoms = mol.GetAtoms()
    conf = mol.GetConformer(conf_id)
    lines = [str(len(atoms)), "generated by moldis"]
    for a in atoms:
        pos = conf.GetAtomPosition(a.GetIdx())
        lines.append(f"{a.GetSymbol()} {pos.x:.6f} {pos.y:.6f} {pos.z:.6f}")
    return "\n".join(lines) + "\n"


def run_xtb_singlepoint(
    mol, conf_id: int = 0, charge: int = 0, spin: int = 0, timeout_s: int = 60
) -> XTBResult:
    """Optional xTB single-point energy wrapper.

    Returns aggregate properties only; if xTB is not installed, returns success=False.
    """
    if not xtb_available():
        return XTBResult(False, None, None, None, None, message="xtb not available")
    try:
        xyz = _mol_to_xyz(mol, conf_id=conf_id)
        with tempfile.TemporaryDirectory() as tmpd:
            tmp = Path(tmpd)
            (tmp / "mol.xyz").write_text(xyz, encoding="utf-8")
            cmd = ["xtb", "mol.xyz", "--sp", "--chrg", str(charge)]
            if spin:
                cmd += ["--uhf", str(spin)]
            proc = subprocess.run(
                cmd,
                cwd=str(tmp),
                capture_output=True,
                text=True,
                timeout=timeout_s,
            )
            out = (
                (tmp / "xtb.out").read_text(encoding="utf-8", errors="ignore")
                if (tmp / "xtb.out").exists()
                else proc.stdout
            )
            # Parse simple fields
            energy = None
            homo = None
            lumo = None
            dipole = None
            for line in out.splitlines():
                s = line.strip()
                if "TOTAL ENERGY" in s.upper() and "Eh" in s:
                    try:
                        energy = float(s.split()[3])  # fragile but acceptable as best-effort
                    except Exception:
                        pass
                if s.lower().startswith("homo-lumo gap") and "homo" in s.lower():
                    # Not standardized; skip robust parsing here
                    pass
                if s.lower().startswith("molecular dipole") and "debye" in s.lower():
                    try:
                        dipole = float(s.split()[-2])
                    except Exception:
                        pass
            return XTBResult(True, energy, homo, lumo, dipole)
    except subprocess.TimeoutExpired:
        return XTBResult(False, None, None, None, None, message="xtb timeout")
    except Exception as e:
        return XTBResult(False, None, None, None, None, message=str(e))
